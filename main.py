import sys
import os
import glob
import re
import json
import shutil
import textwrap
import webbrowser

from typing import List
from PyQt6.QtCore import Qt, QStringListModel
from PyQt6.QtGui import (
    QPixmap, QShortcut, QKeySequence, QAction, QIcon
)

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QFileDialog, QMessageBox,
    QTabWidget, QCompleter, QFileDialog, QMenu
)

from main_window_ui import Ui_MainWindow          # generated by pyuic6
from trainer_parser import TrainerParser, Trainer, Pokemon
from PokemonTab      import PokemonTab
from EventScriptEditor import EventScriptEditor



SHOWDOWN_HEADER = r"""/*
Trainers and their parties defined with Competetive Syntax.
Compatible with Pokemon Showdown exports.
https://github.com/smogon/pokemon-showdown/blob/master/sim/TEAMS.md


A trainer specification starts with ""=== TRAINER_XXXX ===""
and includes everything until the next line that starts with ""===""
or the file ends.
A blank line is required between the trainer and their Pokemon
and between their Pokemon.
TRAINER_XXXX is how the trainer is referred to within code.

Fields with description and/or example of usage
Required fields for trainers:
    - Name
    - Pic
Optional (but still recommended) fields for trainers:
    - Class (if not specified, PkMn Trainer will be used)
    - Gender (Male/Female, affects random gender weights of party if not specified)
    - Music
    - Items (Some Item / Another Item / Third Item)
            (Can also be specified with ITEM_SOME_ITEM)
    - Battle Type (Singles / Doubles, defaults to Singles)
    - AI (Ai Flag / Another Flag / Third Flag / ...
          see ""constants/battle_ai.h"" for all flags)
    - Mugshot (enable Mugshots during battle transition
               set to one of Purple, Green, Pink, Blue or Yellow)
    - Starting Status (see include/constants/battle.h for values)

Pokemon are then specified using the Showdown Export format.
If a field is not specified, it will use it's default value.

Required fields for Pokemon:
    - Species (Either as SPECIES_ABRA or Abra)
      This line also specifies Gender, Nickname and Held item.
      Alfred (Abra) (M) @ Eviolite
      Roberta (SPECIES_ABRA) (F) @ ITEM_CHOICE_SPECS
      Both lines are valid. Gender (M) or (F) must use a capital letter.
      Nickname length is limited to 10 characters using standard letters.
      With narrow font it's increased to 12. Longer strings will be silently shortened.

Optional fields for Pokemon:
    - Level (Number between 1 and 100, defaults to 100)
    - Ability (Ability Name or ABILITY_ABILITY_NAME)
    - IVs (0 HP / 1 Atk / 2 Def / 3 SpA / 4 SpD / 5 Spe, defaults to all 31)
          (Order does not matter)
    - EVs (252 HP / 128 Spe / 48 Def, defaults to all 0, is not capped at 512 total)
          (Order does not matter)
    - Ball (Poke Ball or ITEM_POKE_BALL, defaults to Poke Ball)
    - Happiness (Number between 1 and 255)
    - Nature (Rash or NATURE_RASH, defaults to Hardy)
    - Shiny (Yes/No, defaults to No)
    - Dynamax Level (Number between 0 and 10, default 10, also sets ""shouldDynamax"" to True)
    - Gigantamax (Yes/No, sets to Gigantamax factor)
                 (doesn't do anything to Pokemon without a Gigantamax form, also sets ""shouldDynamax"" to True)
    - Tera Type (Set to a Type, either Fire or TYPE_FIRE, also sets ""shouldTerastal"" to True)
Moves are defined with a - (dash) followed by a single space, then the move name.
Either ""- Tackle"" or ""- MOVE_TACKLE"" works. One move per line.
Moves have to be the last lines of a Pokemon.
If no moves are specified, the Pokemon will use the last 4 moves it learns
through levelup at its level.

Default IVs and Level can be changed in the ""main"" function of tools/trainerproc/main.c

This file is processed with a custom preprocessor.
*/

/*
Comments can be added as C comment blocks
// cannot be used as comments
*/

/*Comments can also be on a single line*/


=== TRAINER_NONE ===
Name:
Class: Pkmn Trainer 1
Pic: Hiker
Gender: Male
Music: Male
Double Battle: No
"""

# ──────────────────────────────  Helper  ──────────────────────────────
def normalize(txt: str) -> str:
    return re.sub(r"[^a-z0-9]", "", txt.lower())



# ──────────────────────────────  Main Window  ─────────────────────────
class MainApp(QMainWindow):
    """Main application window for the Pokeemerald-Expansion Editor."""

    MAX_RECENT = 6  # Max number of recent projects to keep
    SETTINGS_FILE = os.path.join(os.getcwd(), "pe_editor_settings.json")

    def __init__(self) -> None:
        super().__init__()

        # ---------- UI setup ----------
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.ui.textBrowser_2.setOpenExternalLinks(True)
        self.ui.textBrowser.setOpenExternalLinks(True)

        self.setWindowTitle("Expansion Editor")
        self.ui.btnCreateTrainer.clicked.connect(self.create_new_trainer)

        # Main Pokémon tab widget (hidden unless TrainerEditor page is active)
        self.party_tabs = QTabWidget()
        self.ui.partyLayout.addWidget(self.party_tabs)
        self.party_tabs.setVisible(False)

        # Global shortcut
        QShortcut(QKeySequence("Ctrl+S"), self, activated=self.save_to_file)

        # ---------- Recent-projects ----------
        self.recent_projects: List[str] = self.load_recent_projects()
        self.recent_actions: List[QAction] = []

        self.recent_menu = QMenu("Open Recent Projects", self)
        self.ui.actionRecentProjectss.setMenu(self.recent_menu)

        self.update_recent_projects_menu()

        # ---------- Data parser ----------
        self.project_folder: str = ""
        self.parser = TrainerParser()
        self.trainers: List[Trainer] = []
        self.ai_flags: List[str] = []
        self.music_tracks: List[str] = []
        self.classes: List[str] = []
        self.pics: List[str] = []

        self.species: List[str] = []
        self.moves: List[str] = []
        self.items: List[str] = []
        self.natures: List[str] = []
        self.abilities: List[str] = []
        self.balls: List[str] = []
        self.tera_types: List[str] = []
        self.original_trainers: List[str] = []  # snapshot for unsaved-check

        # ---------- Signals ----------
        self.ui.actionOpenProjectFolder.triggered.connect(self.choose_folder)
        self.ui.actionTrainerEditor.triggered.connect(
            lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.TrainerEditor)
        )
        self.ui.actionImportTrainerPics.triggered.connect(
            lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.pageImportTrainerPics)
        )
        self.ui.importButton.clicked.connect(self.import_trainer_pics)
        self.ui.actionSave.triggered.connect(self.save_to_file)
        self.ui.comboTrainerDropdown.currentIndexChanged.connect(self.update_trainer_fields)
        self.ui.comboTrainerPic.currentTextChanged.connect(self.on_trainer_pic_changed)
        self.ui.stackedWidget.currentChanged.connect(self.on_page_changed)
        self.ui.comboTeamSize.addItems([str(n) for n in range(1, 7)])
        self.ui.comboTeamSize.currentIndexChanged.connect(self.on_team_size_changed)
        self.ui.actionNewTrainerPage.triggered.connect(
            lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.newTrainer)
        )
        self.ui.actionImportOverworldSprites.triggered.connect(self.open_overworld_import)
        self.ui.importButton_OW.clicked.connect(self.import_overworld_sprites)
        self.ui.actionReloadProjectFolder.triggered.connect(self.reload_project_data)
        self.ui.actionMapScriptEditor_2.triggered.connect(
            lambda: self.ui.stackedWidget.setCurrentWidget(self.ui.pageMapScripts)
        )

                                    
        # Make some comboboxes editable/searchable
        for cb in (
            self.ui.comboTrainerClass,
            self.ui.comboTrainerPic,
            self.ui.comboTrainerGender,
            self.ui.comboTrainerMusic,
        ):
            cb.setEditable(True)

        # ---------- Auto-load last used project ----------
        if self.recent_projects:
            last = self.recent_projects[0]
            if os.path.isdir(last):
                self.eventScriptEditor = EventScriptEditor("")
                self.ui.layoutEventScript.addWidget(self.eventScriptEditor)
                self.load_project(last)

    def generate_map_script(self, trainer_id: str, map_name: str) -> str:
        return textwrap.dedent(f"""\
            // Auto-generated map script for {map_name}

            {map_name}_TrainerScript::
                lock
                faceplayer
                msgbox gText_HelloThere
                trainerbattle0 {trainer_id}, gText_Lose, gText_Win
                release
                end

            mapscripts {map_name}
                mapscript MAP_SCRIPT_ON_LOAD, {map_name}_TrainerScript
                endm
        """)
    def update_script_preview(self):
        trainer_id = self.ui.comboTrainerDropdown.currentText().strip()
        if not map_name or not trainer_id:
            self.ui.plainScript.setPlainText("// Select map and trainer")
            return

        script = self.generate_map_script(trainer_id, map_name)
        self.ui.plainScript.setPlainText(script)

    def update_script_preview(self):
        trainer_id = self.ui.comboTrainerDropdown.currentText().strip()
        if not map_name or not trainer_id:
            self.ui.plainScript.setPlainText("// Select map and trainer")
            return

        script = self.generate_map_script(trainer_id, map_name)
        self.ui.plainScript.setPlainText(script)

    def save_map_script(self):
        if not map_name:
            QMessageBox.warning(self, "Missing map", "Please enter/select a map name.")
            return

        script = self.ui.plainScript.toPlainText()
        script_dir = os.path.join(self.project_folder, "data", "scripts", "maps")
        os.makedirs(script_dir, exist_ok=True)

        out_path = os.path.join(script_dir, f"{map_name.lower()}.pory")
        try:
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(script)
            QMessageBox.information(self, "Saved", f"Script saved to:\n{out_path}")
        except Exception as e:
            QMessageBox.critical(self, "Save Error", str(e))

    def populate_map_names(self):
        maps_dir = os.path.join(self.project_folder, "data", "maps")
        if not os.path.isdir(maps_dir):
            return
        maps = [os.path.splitext(f)[0] for f in os.listdir(maps_dir) if f.endswith(".map")]

    def reload_data_only(self) -> None:
        """Reload all trainer data from disk, but stay on current page."""
        if not os.path.isdir(self.project_folder):
            return
        try:
            self.parser.load_trainers(os.path.join(self.project_folder, "src/data/trainers.party"))
            self.trainers = self.parser.trainers
            self.populate_trainer_dropdown()
            self.original_trainers = self._snapshot_trainers()
        except Exception as e:
            QMessageBox.critical(self, "Reload error", str(e))
    def reload_project_data(self) -> None:
        """Reload all project data (trainers, species, items, etc.) without changing the GUI page."""
        if not os.path.isdir(self.project_folder):
            return
        try:
            self.parser.load_trainers(os.path.join(self.project_folder, "src/data/trainers.party"))
            self.parser.load_species(os.path.join(self.project_folder, "src/data/pokemon"))
            self.parser.load_moves(os.path.join(self.project_folder, "include/constants/moves.h"))
            self.parser.load_items(os.path.join(self.project_folder, "include/constants/items.h"))
            self.parser.load_natures(os.path.join(self.project_folder, "include/constants/nature.h"))
            self.parser.load_abilities(os.path.join(self.project_folder, "include/constants/abilities.h"))
            self.parser.load_tera_types(os.path.join(self.project_folder, "include/constants/pokemon.h"))

            self.trainers = self.parser.trainers
            self.populate_trainer_dropdown()
            self.original_trainers = self._snapshot_trainers()

            print("✅ All project data reloaded successfully.")
        except Exception as e:
            QMessageBox.critical(self, "Reload error", str(e))

    def create_new_trainer(self):
        if not self.project_folder:
            self.ui.labelCreateTrainerStatus.setText("❌ No project folder set.")
            return

        name = self.ui.inputTrainerName.text().strip()
        if not name:
            self.ui.labelCreateTrainerStatus.setText("❌ Please enter a trainer name.")
            return

        trainer_id = "TRAINER_" + re.sub(r"\s+", "_", name.upper())
        opp_path = os.path.join(self.project_folder, "include", "constants", "opponents.h")
        party_path = os.path.join(self.project_folder, "src", "data", "trainers.party")

        if not os.path.isfile(opp_path) or not os.path.isfile(party_path):
            self.ui.labelCreateTrainerStatus.setText("❌ Missing opponents.h or trainers.party.")
            return

        try:
            # Les og oppdater opponents.h
            with open(opp_path, encoding="utf-8") as f:
                lines = f.readlines()

            count_i = next(i for i, l in enumerate(lines) if l.startswith("#define TRAINERS_COUNT"))
            max_i   = next(i for i, l in enumerate(lines) if l.startswith("#define MAX_TRAINERS_COUNT"))
            trainer_count = int(re.search(r"\d+", lines[count_i]).group())
            max_count     = int(re.search(r"\d+", lines[max_i]).group())



            # Sjekk om allerede finnes
            if any(trainer_id in l for l in lines):
                self.ui.labelCreateTrainerStatus.setText(f"❌ {trainer_id} already exists.")
                return
            
            # SJEKK GRENSE
            if trainer_count >= max_count or trainer_count >= 1200:
                self.ui.labelCreateTrainerStatus.setText("❌ Max number of trainers reached (1200).")
                return
            
            new_id = trainer_count
            # Fjern gamle COUNT-linjer
            del lines[max_i]
            del lines[count_i]

            # Sett inn ny trener + oppdaterte tellere
            lines.insert(count_i, f"#define {trainer_id} {new_id}\n")
            lines.insert(count_i + 1, f"#define TRAINERS_COUNT {trainer_count + 1}\n")
            lines.insert(count_i + 2, f"#define MAX_TRAINERS_COUNT {max_count + 1}\n")


            with open(opp_path, "w", encoding="utf-8") as f:
                f.writelines(lines)

            # Legg til i trainers.party
            block = textwrap.dedent(f"""
    === {trainer_id} ===
    Name: {name}
    Class: Pkmn Trainer 1
    Pic: Hiker
    Gender: Male
    Music: Male
    Double Battle: No

    Bulbasaur
    Level: 50
""")

            with open(party_path, "a", encoding="utf-8") as f:
                f.write(block)

            self.ui.labelCreateTrainerStatus.setText(f"✅ Created {trainer_id}.")
            self.reload_data_only()

        except Exception as e:
            self.ui.labelCreateTrainerStatus.setText(f"❌ Error: {e}")

    def open_overworld_import(self):
        self.ui.stackedWidget.setCurrentWidget(self.ui.pageImportOWSprite)
        self.ui.labelOverworldInfo.setTextFormat(Qt.TextFormat.RichText)

    def import_overworld_sprites(self):
        png_files, _ = QFileDialog.getOpenFileNames(self, "Select PNG files", "", "PNG Files (*.png)")
        if not png_files:
            self.ui.labelImportOverworldStatus.setText("❌ No PNG files selected.")
            return

        dest_dir = os.path.join(self.project_folder, "graphics/object_events/pics/people")
        os.makedirs(dest_dir, exist_ok=True)

        constants_path = os.path.join(self.project_folder, "include/constants/event_objects.h")
        if not os.path.exists(constants_path):
            self.ui.labelImportOverworldStatus.setText("❌ Missing event_objects.h")
            return

        with open(constants_path, "r", encoding="utf-8") as f:
            lines = f.readlines()

        gfx_line_index = next((i for i, line in enumerate(lines) if "#define NUM_OBJ_EVENT_GFX" in line), -1)
        if gfx_line_index == -1:
            self.ui.labelImportOverworldStatus.setText("❌ Could not find NUM_OBJ_EVENT_GFX.")
            return

        try:
            current_id = int(lines[gfx_line_index].split()[-1])
        except ValueError:
            self.ui.labelImportOverworldStatus.setText("❌ Invalid number for NUM_OBJ_EVENT_GFX.")
            return

        imported = 0
        for path in png_files:
            name = os.path.splitext(os.path.basename(path))[0].lower()
            upper = name.upper()
            marker = f"//New_PIC {name}.png"
            define_line = f"#define OBJ_EVENT_GFX_{upper} {current_id}\n"
            dest_png = os.path.join(dest_dir, name + ".png")

            if any(f"OBJ_EVENT_GFX_{upper}" in line for line in lines):
                continue  # skip duplicates

            shutil.copyfile(path, dest_png)
            lines.insert(gfx_line_index, define_line)
            lines.insert(gfx_line_index, marker + "\n")
            current_id += 1
            imported += 1

        lines[gfx_line_index + 2] = f"#define NUM_OBJ_EVENT_GFX {current_id}\n"

        with open(constants_path, "w", encoding="utf-8") as f:
            f.writelines(lines)

        self.ui.labelImportOverworldStatus.setText(f"✅ Imported {imported} overworld sprite(s).")

    # ───────────────────── Unsaved-changes utilities ──────────────────
    def _snapshot_trainers(self) -> List[str]:
        """Return list of repr strings for every trainer (deep-enough for diff)."""
        return [repr(t) for t in self.trainers]

    def has_unsaved_changes(self) -> bool:
        return self._snapshot_trainers() != self.original_trainers
    
    # ───────────────────── Recent-project helpers ─────────────────────
    def load_recent_projects(self) -> List[str]:
        try:
            with open(self.SETTINGS_FILE, "r", encoding="utf-8") as f:
                return json.load(f).get("recent_projects", [])
        except Exception:
            return []

    def save_recent_projects(self) -> None:
        try:
            with open(self.SETTINGS_FILE, "w", encoding="utf-8") as f:
                json.dump({"recent_projects": self.recent_projects}, f)
        except Exception:
            pass

    def update_recent_projects_menu(self) -> None:
        self.recent_menu.clear()
        self.recent_actions.clear()

        if not self.recent_projects:
            self.recent_menu.addAction("(No recent projects)").setEnabled(False)
            return

        for path in self.recent_projects[:self.MAX_RECENT]:
            act = QAction(path, self)
            act.triggered.connect(lambda checked=False, p=path: self.load_project(p))
            
            self.recent_menu.addAction(act)
            self.recent_actions.append(act)

    # ───────────────────────── UI visibility ──────────────────────────
    def on_page_changed(self, index: int) -> None:
        current_page = self.ui.stackedWidget.widget(index)
        self.party_tabs.setVisible(current_page == self.ui.TrainerEditor)

    # ─────────────────────── Choose / load folder ──────────────────────
    def choose_folder(self) -> None:
        folder = QFileDialog.getExistingDirectory(
            self, "Select project folder", self.project_folder or ""
        )
        if folder:
            self.load_project(folder)

    def load_project(self, folder: str) -> None:
        """Load data from the selected pokeemerald-expansion project."""
        if not os.path.isdir(folder):
            QMessageBox.warning(self, "Folder missing", folder)
            return

        self.project_folder = folder
        self.ui.lblFolderPath.setText(folder)
        self.setWindowTitle(f"Expansion Editor – {folder}")

        # Opprett editor hvis den ikke finnes ennå
        # ----- etter -----
        if not hasattr(self, "eventScriptEditor"):
            self.eventScriptEditor = EventScriptEditor(
                folder,
                species_list=self.parser.species       #  ← sender lista inn nå
            )
            self.ui.layoutEventScript.addWidget(self.eventScriptEditor)
        else:
            self.eventScriptEditor.set_project_folder(folder)
            self.eventScriptEditor.set_species_list(self.parser.species)

        # Oppdater nylig brukte prosjekter
        if folder in self.recent_projects:
            self.recent_projects.remove(folder)
        self.recent_projects.insert(0, folder)
        self.recent_projects = self.recent_projects[:self.MAX_RECENT]
        self.save_recent_projects()
        self.update_recent_projects_menu()
        self.ui.stackedWidget.setCurrentWidget(self.ui.openedProject)

        try:
            self.parser.load_trainers(os.path.join(folder, "src/data/trainers.party"))
            self.parser.load_species(os.path.join(folder, "src/data/pokemon/species_info"))
            self.parser.load_moves(os.path.join(folder, "include/constants/moves.h"))
            self.parser.load_items(os.path.join(folder, "include/constants/items.h"))
            self.parser.load_natures(os.path.join(folder, "include/constants/pokemon.h"))
            self.parser.load_abilities(os.path.join(folder, "include/constants/abilities.h"))
            self.parser.load_tera_types(os.path.join(folder, "include/constants/pokemon.h"))

            self.trainers = self.parser.trainers
            # oppdater dropdown-ene i eksisterende editor
            if hasattr(self, "eventScriptEditor"):
                self.eventScriptEditor.set_species_list(self.parser.species)

            self.populate_static_dropdowns()
            self.populate_trainer_dropdown()
            self.init_ai_flag_dropdown(self.parser.ai_flags)
            self.original_trainers = self._snapshot_trainers()
            self.populate_map_names()

            # Oppdater HTML-panelet hvis det finnes
            if hasattr(self.ui, "textProjectInfo"):
                self.ui.textProjectInfo.setOpenExternalLinks(True)
                self.ui.textProjectInfo.setHtml(f"""
                    <h2 style='color: lightgreen;'>🎉 Project Folder Loaded!</h2>
                    <p><b>You're ready to roll!</b><br>
                    You've selected the following folder as your <code>pokeemerald-expansion</code> project:</p>
                    <p><code>{folder}</code></p>
                    <p>This tool is now fully unlocked and ready to help you <b>edit, enhance, and expand</b> your Pokémon world. 🔧🚀</p>

                    <h3>✨ What you can do now:</h3>
                    <ul>
                        <li>➕ <b>Create brand new trainers</b> with fully customized teams</li>
                        <li>✏️ <b>Edit existing trainers</b> already in your project</li>
                        <li>🖼️ <b>Import trainer front sprites</b> (.png format)</li>
                        <li>🚶 <b>Import overworld sprites</b> (object event graphics)</li>
                        <li>💾 <b>Remember:</b> changes are <i>not</i> auto-saved — hit <b>Save</b> before exiting!</li>
                    </ul>

                    <h3>📊 Loaded Data:</h3>
                    <ul>
                        <li><b>Trainers:</b> {len(self.trainers)}</li>
                    </ul>
                    <p>Return to the sidebar to start building your perfect Pokémon experience. Let’s make something amazing! 💡🕹️</p>
                """)

        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))

    # New Trainer
    # ─────────────────────── Import trainer pics ───────────────────────
    def import_trainer_pics(self) -> None:
        if not self.project_folder:
            QMessageBox.warning(self, "No folder", "Choose a project folder first.")
            return

        files, _ = QFileDialog.getOpenFileNames(
            self, "Select PNGs", self.project_folder, "PNG Files (*.png)"
        )
        if not files:
            self.ui.debugLabel.setText("No files selected.")
            self.ui.debugLabel.setStyleSheet("color: red;")
            return

        dest = os.path.join(self.project_folder, "graphics", "trainers", "front_pics")
        os.makedirs(dest, exist_ok=True)

        for path in files:
            shutil.copy(path, os.path.join(dest, os.path.basename(path)))

        self.ui.debugLabel.setText(f"Imported {len(files)} trainer images.")
        self.ui.debugLabel.setStyleSheet("color: green;")

    def on_trainer_pic_changed(self, text: str):
        if text:
            self.load_trainer_image(text)

    # ------------------------------------------------------------------
    def apply_changes_to_current_trainer(self):
        idx = self.ui.comboTrainerDropdown.currentIndex()
        if idx < 0 or idx >= len(self.trainers):
            return

        trainer = self.trainers[idx]

        trainer.name = self.ui.lineTrainerName.text().strip()
        trainer.class_ = self.ui.comboTrainerClass.currentText().strip()
        trainer.gender = self.ui.comboTrainerGender.currentText().strip()
        trainer.music = self.ui.comboTrainerMusic.currentText().strip()
        trainer.double_battle = self.ui.checkDoubleBattle.isChecked()

        # Hent riktig bilde-ID hvis displaynavnet er forskjellig
        display_name = self.ui.comboTrainerPic.currentText()
        trainer.pic = self.trainer_pic_lookup.get(display_name, display_name)

        # AI-flagg (bare ett støttes nå)
        text = self.ui.comboAIFlags.currentText().strip()
        trainer.ai_flags = [text] if text else []
        trainer.items = []

        # Mugshot
        text = self.ui.comboMugshot.currentText().strip()
        trainer.mugshot = text if text and text != "None" else None

        # Items
        trainer.items = []
        for cb in (self.ui.comboTrainerItem1, self.ui.comboTrainerItem2, self.ui.comboTrainerItem3):
            val = cb.currentText().strip()
            if val and val != "None":
                trainer.items.append(val)

        # Pokémon-tabber → sync tilbake til .party
        for i in range(self.party_tabs.count()):
            tab = self.party_tabs.widget(i)
            if hasattr(tab, "apply_changes"):
                tab.apply_changes()

    #  SAVE  – exports trainers.party and updates include/constants/opponents.h
    # ------------------------------------------------------------------
    def save_to_file(self):
        # ① Validation --------------------------------------------------
        def stat_line(vals, label):
            names = ["HP", "Atk", "Def", "SpA", "SpD", "Spe"]
            parts = [f"{v} {names[i]}" for i, v in enumerate(vals) if v is not None and v != 0]
            if parts:
                out.append(f"{label}: " + " / ".join(parts))

        if not self.project_folder:
            QMessageBox.warning(self, "Save", "No project folder loaded yet.")
            return
        if not self.trainers:
            QMessageBox.warning(self, "Save", "No trainers to save.")
            return

        self.apply_changes_to_current_trainer()
        trainer_path   = os.path.join(self.project_folder, "src", "data", "trainers.party")
        opponents_path = os.path.join(self.project_folder, "include", "constants", "opponents.h")

        # ② Build .party file ------------------------------------------
        out = [SHOWDOWN_HEADER.rstrip(), ""]          # header + blank line

        for tr in self.trainers:
            if tr.id in ("TRAINER_NONE", "") or tr.id.startswith("TRAINER_XXXX"):
                continue

            out += [
                f"=== {tr.id} ===",
                f"Name: {tr.name}",
                f"Class: {tr.class_}",
                f"Pic: {tr.pic}",
                f"Gender: {tr.gender}",
                f"Music: {tr.music}",
                f"Double Battle: {'Yes' if tr.double_battle else 'No'}",
            ]

            # optional fields ------------------------------------------
            if getattr(tr, "mugshot", None) and tr.mugshot not in ("", "None"):
                out.append(f"Mugshot: {tr.mugshot}")

            if tr.items:
                good = [i for i in tr.items if i and i != "None"]
                if good:
                    out.append(f"Items: {' / '.join(good)}")

            if tr.ai_flags and any(tr.ai_flags):
                out.append(f"AI: {' / '.join(filter(None, tr.ai_flags))}")
                out.append("")
            else:
                out.append("")  # bare en tom linje, ingen "AI:"

            # ③ Pokémon -------------------------------------------------
            for p in tr.party:
                held = f" @ {p.held_item}" if p.held_item and p.held_item != "None" else ""
                
            # Bestem species-delen
                if p.nickname:
                    species_part = f"{p.nickname} ({p.species})"
                else:
                    species_part = p.species

                # Bestem kjønn
                if p.gender == "M":
                    gender_part = " (M)"
                elif p.gender == "F":
                    gender_part = " (F)"
                else:
                    gender_part = ""

                # Bestem item
                held = f" @ {p.held_item}" if p.held_item and p.held_item != "None" else ""

                # Sett sammen
                out.append(f"{species_part}{gender_part}{held}")

                out.append(f"Level: {p.level}")

                # ability / nature / etc
                if p.ability and p.ability != "None":
                    out.append(f"Ability: {p.ability}")
                if p.nature and p.nature != "None":
                    out.append(f"Nature: {p.nature}")
                if p.happiness is not None:
                    out.append(f"Happiness: {p.happiness}")
                if p.ball and p.ball != "None":
                    out.append(f"Ball: {p.ball}")
                if p.tera_type and p.tera_type != "None":
                    out.append(f"Tera Type: {p.tera_type}")
                if p.dynamax_level > 0:
                    out.append(f"Dynamax Level: {p.dynamax_level}")
                if p.is_shiny:
                    out.append("Shiny: Yes")
                if p.is_gigantamax:
                    out.append("Gigantamax: Yes")
                # IVs / EVs
                stat_line(p.ivs, "IVs")
                stat_line(p.evs, "EVs")

                # moves
                for m in p.moves:
                    out.append(f"- {m}")
                out.append("")  # blank line between mons

            out.append("")      # blank line between trainers

        # write file
        try:
            with open(trainer_path, "w", encoding="utf-8") as fh:
                fh.write("\n".join(out))
            QMessageBox.information(self, "Save", f"Trainers saved to:\n{trainer_path}")
        except OSError as err:
            QMessageBox.critical(self, "Save error", str(err))
            return

        # ④ Update opponents.h -----------------------------------------
        try:
            if not os.path.isfile(opponents_path):
                return  # file absent → silently skip

            with open(opponents_path, encoding="utf-8") as fh:
                lines = fh.readlines()

            define_rx   = re.compile(r"#define\s+(TRAINER_[A-Z0-9_]+)\s+(\d+)")
            existing    = {m.group(1): int(m.group(2)) for m in map(define_rx.match, lines) if m}
            max_val     = max(existing.values()) if existing else -1
            inserted    = False

            for tr in self.trainers:
                if tr.id.startswith("TRAINER_") and tr.id not in existing:
                    max_val += 1
                    lines.append(f"#define {tr.id} {max_val}\n")
                    existing[tr.id] = max_val
                    inserted = True

            if inserted:
                # update *_COUNT lines
                for i, ln in enumerate(lines):
                    if ln.startswith("#define TRAINERS_COUNT"):
                        lines[i] = f"#define TRAINERS_COUNT                      {max_val+1}\n"
                    if ln.startswith("#define MAX_TRAINERS_COUNT"):
                        lines[i] = f"#define MAX_TRAINERS_COUNT                  {max_val+9}\n"

                with open(opponents_path, "w", encoding="utf-8") as fh:
                    fh.writelines(lines)
        except OSError as err:
            QMessageBox.warning(self, "Opponents.h", f"Could not update opponents.h:\n{err}")

        # ⑤ Refresh snapshot → no unsaved changes now ------------------
        self.original_trainers = self._snapshot_trainers()

    # ────────────────────────────────────────────────  DROPDOWNS  ──
    def populate_static_dropdowns(self):
        self.ui.comboTrainerClass.clear()
        self.ui.comboTrainerClass.addItems(self.parser.classes)

        self.ui.comboMugshot.clear()
        self.ui.comboMugshot.addItems(["None", "Purple", "Green", "Pink", "Blue", "Yellow"])

        self.ui.comboTrainerGender.clear()
        self.ui.comboTrainerGender.addItems(["Male", "Female", "Unknown"])

        self.ui.comboTrainerMusic.clear()
        self.ui.comboTrainerMusic.addItems(self.parser.music_tracks)

        # ─── Last inn bilder fra mappen ───
        self.ui.comboTrainerPic.clear()
        pic_folder = os.path.join(self.project_folder, "graphics", "trainers", "front_pics")

        display_to_actual = {}  # For eventuell videre bruk

        if os.path.isdir(pic_folder):
            files = glob.glob(os.path.join(pic_folder, "*.png"))
            for path in files:
                filename = os.path.splitext(os.path.basename(path))[0]
                display_name = filename.replace("_", " ").title()
                display_to_actual[display_name] = filename

        sorted_display_names = sorted(display_to_actual.keys(), key=str.casefold)
        self.ui.comboTrainerPic.addItems(sorted_display_names)

        # Hvis du trenger originalnavnene igjen:
        self.trainer_pic_lookup = display_to_actual
        for cb in (self.ui.comboTrainerItem1, self.ui.comboTrainerItem2, self.ui.comboTrainerItem3):
            cb.clear()
            cb.addItem("None")
            cb.addItems(self.parser.items)
            cb.setEditable(True)  # valgfritt: gjør dem søkbare/autocomplete

    def populate_trainer_dropdown(self):
        self.ui.comboTrainerDropdown.clear()
        self.ui.comboTrainerDropdown.setEditable(True)

        ids = [t.id for t in self.trainers]
        self.ui.comboTrainerDropdown.addItems(ids)

        comp = QCompleter()
        comp.setModel(QStringListModel(ids))
        comp.setFilterMode(Qt.MatchFlag.MatchContains)
        comp.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.ui.comboTrainerDropdown.setCompleter(comp)

        # vis første trener
        if ids:
            self.ui.comboTrainerDropdown.setCurrentIndex(0)

    def init_ai_flag_dropdown(self, ai_flags: List[str]):
        self.ui.comboAIFlags.clear()
        self.ui.comboAIFlags.addItems(ai_flags)

    # ────────────────────────────────────────────────  VIEW UPDATE  ──
    def update_trainer_fields(self):
        idx = self.ui.comboTrainerDropdown.currentIndex()
        if idx < 0 or idx >= len(self.trainers):
            return

        trainer = self.trainers[idx]

        self.ui.comboMugshot.setCurrentText(trainer.mugshot or "None")

        # all «vanlig» info
        self.ui.lineTrainerName.setText(trainer.name)
        self.ui.comboTrainerClass.setCurrentText(trainer.class_)
        self.ui.comboTrainerPic.setCurrentText(trainer.pic)
        self.ui.comboTrainerGender.setCurrentText(trainer.gender)
        self.ui.comboTrainerMusic.setCurrentText(trainer.music)
        self.ui.checkDoubleBattle.setChecked(trainer.double_battle)

        # AI-flag
        self.ui.comboAIFlags.setCurrentText(trainer.ai_flags[0] if trainer.ai_flags else "")

        # team-size dropdown
        self.ui.comboTeamSize.blockSignals(True)
        self.ui.comboTeamSize.setCurrentText(str(len(trainer.party)))
        self.ui.comboTeamSize.blockSignals(False)

        # bilde av trener
        self.load_trainer_image(trainer.pic)
        self.ui.comboTrainerPic.currentTextChanged.disconnect()
        self.ui.comboTrainerPic.currentTextChanged.connect(self.load_trainer_image)

        # Items
        item_combos = [self.ui.comboTrainerItem1, self.ui.comboTrainerItem2, self.ui.comboTrainerItem3]
        for i, cb in enumerate(item_combos):
            cb.blockSignals(True)
            cb.setCurrentText(trainer.items[i] if i < len(trainer.items) else "None")
            cb.blockSignals(False)

        # Pokémon-faner
        self.refresh_party_tabs(trainer)

    # ────────────────────────────────────────────────  TAB LOGIC  ──
    def refresh_party_tabs(self, trainer: Trainer):
        # fjern gamle tabs
        self.party_tabs.setParent(None)
        self.party_tabs.clear()

        for i, mon in enumerate(trainer.party, start=1):
            tab = PokemonTab(
                mon,
                self.parser.species,
                self.parser.moves,
                self.parser.items,
                self.parser.natures,
                self.parser.abilities,
                self.parser.balls,
                self.parser.tera_types,
                self.project_folder,
            )
            tab.species_changed.connect(lambda name, i=i: self.party_tabs.setTabText(i - 1, f"#{i} {name}"))
            self.party_tabs.addTab(tab, f"#{i} {mon.species or 'Pokémon'}")

        self.ui.partyLayout.addWidget(self.party_tabs)

    def on_team_size_changed(self, index: int):
        """Kalles når brukeren endrer antall Pokémon (index 0→ size 1, …)."""
        target_size = index + 1
        trainer_idx = self.ui.comboTrainerDropdown.currentIndex()
        if trainer_idx < 0 or trainer_idx >= len(self.trainers):
            return

        trainer = self.trainers[trainer_idx]
        current = len(trainer.party)

        # utvid
        if target_size > current:
            for _ in range(target_size - current):
                trainer.party.append(self.make_default_pokemon())

        # krymp
        elif target_size < current:
            trainer.party = trainer.party[:target_size]

        self.refresh_party_tabs(trainer)

    # ────────────────────────────────────────────────  HELPERS  ──
    def make_default_pokemon(self) -> Pokemon:
        """Returnerer en enkel Bulbasaur Lv 5 uten moves/items."""
        return Pokemon(
            nickname        = "",
            species         = "Bulbasaur",
            level           = 5,
            moves           = [],
            ivs             = [None] * 6,
            evs             = [None] * 6,
        )

    def load_trainer_image(self, pic_name: str):
        self.ui.lblTrainerPic.clear()
        pic_folder = os.path.join(self.project_folder, "graphics", "trainers", "front_pics")
        if not os.path.isdir(pic_folder):
            self.ui.lblTrainerPic.setText("Folder missing")
            return

        target = normalize(pic_name)
        all_png = glob.glob(os.path.join(pic_folder, "*.png"))

        chosen = next((p for p in all_png if normalize(os.path.splitext(os.path.basename(p))[0]) == target), None)
        if not chosen:
            chosen = next((p for p in all_png if normalize(os.path.basename(p)).startswith(target)), None)

        if not chosen:
            self.ui.lblTrainerPic.setText("Image not found")
            return

        pm = QPixmap(chosen).scaled(160, 160, Qt.AspectRatioMode.KeepAspectRatio,
                                    Qt.TransformationMode.SmoothTransformation)
        self.ui.lblTrainerPic.setPixmap(pm)

    # ───────────────────────────── CloseEvent ─────────────────────────
    def closeEvent(self, event):
        if self.has_unsaved_changes():
            reply = QMessageBox.question(
                self,
                "Unsaved Changes",
                "You have unsaved changes. Do you want to save before exiting?",
                QMessageBox.StandardButton.Save |
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel,
                QMessageBox.StandardButton.Save
            )

            if reply == QMessageBox.StandardButton.Save:
                self.save_to_file()
                event.accept()
            elif reply == QMessageBox.StandardButton.Discard:
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


# ─────────────────────────────── main ────────────────────────────────
if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = MainApp()
    win.show()
    sys.exit(app.exec())
